// SPDX-License-Identifier: GPLv3
pragma solidity 0.8.15;

import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

interface IPangolinStakingPositions {
    struct ValueVariables {
        uint96 balance;
        uint160 sumOfEntryTimes;
    }

    struct RewardSummations {
        uint256 idealPosition;
        uint256 rewardPerValue;
    }

    struct Position {
        ValueVariables valueVariables;
        RewardSummations rewardSummationsPaid;
        uint160 previousValues;
        uint48 lastUpdate;
        uint48 lastDevaluation;
    }

    function positions(uint256 positionId) external view returns (Position memory);

    function positionPendingRewards(uint256 positionId) external view returns (uint256);

    function positionRewardRate(uint256 positionId) external view returns (uint256);
}

contract TokenMetadata is AccessControlEnumerable {
    using Strings for uint256;

    bytes32 public constant METADATA_ROLE = keccak256("METADATA_ROLE");

    bytes1 public thousandSeperator = ",";
    string public description =
        "This NFT perpetually receives share from the revenue generated by Pangolin. The share of the position is positively correlated to its staked balance and staking duration.";
    string public externalUri = "https://app.pangolin.exchange/#/stake/0";
    string public regularFontUri = "https://fonts.gstatic.com/s/poppins/v20/pxiEyp8kv8JHgFVrJJfecg.woff2";
    string public boldFontUri = "https://fonts.gstatic.com/s/poppins/v20/pxiByp8kv8JHgFVrLCz7Z1xlFQ.woff2";
    string public imageBaseUri = "https://pangolin.exchange/static/sar/";
    string public imageExtension = ".png";

    constructor(address newAdmin) {
        require(newAdmin != address(0));
        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);
        _grantRole(METADATA_ROLE, newAdmin);
    }

    function setThousandSeperator(bytes1 newThousandSeperator) external onlyRole(METADATA_ROLE) {
        thousandSeperator = newThousandSeperator;
    }

    function setDescription(string memory newDescription) external onlyRole(METADATA_ROLE) {
        description = newDescription;
    }

    function setExternalUri(string memory newExternalUri) external onlyRole(METADATA_ROLE) {
        externalUri = newExternalUri;
    }

    function setFont(string memory newRegularFontUri, string memory newBoldFontUri)
        external
        onlyRole(METADATA_ROLE)
    {
        regularFontUri = newRegularFontUri;
        boldFontUri = newBoldFontUri;
    }

    function setImage(string memory newImageBaseUri, string memory newImageExtension)
        external
        onlyRole(METADATA_ROLE)
    {
        imageBaseUri = newImageBaseUri;
        imageExtension = newImageExtension;
    }

    function tokenURI(IPangolinStakingPositions pangolinStakingPositions, uint256 positionId)
        external
        view
        returns (string memory)
    {
        IPangolinStakingPositions.ValueVariables memory positionValueVariables =
            pangolinStakingPositions.positions(positionId).valueVariables;

        uint256 balance = positionValueVariables.balance;
        uint256 entryTime = positionValueVariables.sumOfEntryTimes / balance;
        uint256 apr = parseEther(
            (pangolinStakingPositions.positionRewardRate(positionId) * 365 days * 100) / balance
        );
        uint256 earned = parseEther(pangolinStakingPositions.positionPendingRewards(positionId));
        balance = parseEther(balance);

        uint256 balanceLevel = getExponent(balance / 404);
        uint256 durationLevel = getExponent((block.timestamp - entryTime) / 1 days);

        string memory svg;
        {
            svg = Base64.encode(
                abi.encodePacked(
                    '<svg width="663" height="1080" viewbox="0 0 663 1080" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <style type="text/css"> @font-face { font-family: "Poppins"; src: url(',
                    regularFontUri,
                    ') format("woff2"); } @font-face { font-family: "Poppins"; font-weight: bold; src: url(',
                    boldFontUri,
                    ') format("woff2"); } text { color:#1a1a1a; font-family:Poppins, sans-serif; font-size:24.73px; } .data_span { font-weight:bold; font-size:37.09px } .text_bottom .info_span { font-size: 28.81px } .text_bottom .data_span { font-size: 43.21px } </style> <image preserveAspectRatio="xMidYMid slice" width="100%" height="100%" xlink:href="',
                    getImageUri(balanceLevel, durationLevel),
                    '"></image> <text x="27.3" y="54.9" text-anchor="start" class="text_top"><tspan class="info_span">$PNG: </tspan><tspan class="data_span">',
                    addThousandSeperator(balance),
                    '</tspan></text> <text x="635.7" y="54.9" text-anchor="end" class="text_top"><tspan class="info_span">APR: </tspan><tspan class="data_span">',
                    addThousandSeperator(apr),
                    '%</tspan></text> <text x="331.5" y="1001.97" text-anchor="middle" class="text_bottom"><tspan class="info_span">EARNED: </tspan><tspan class="data_span" x="331.5" dy="51.85">$PNG ',
                    addThousandSeperator(earned),
                    '</tspan></text> </svg>'
                )
            );
        }

        string memory json;
        {
            json = Base64.encode(
                abi.encodePacked(
                    '{"name":"Pangolin Staking Position #',
                    positionId.toString(),
                    '","description":"',
                    description,
                    '","external_url":"',
                    externalUri,
                    '","attributes":[{"trait_type":"Balance","value":',
                    balance.toString(),
                    '},{"display_type":"date","trait_type":"Entry Time","value":',
                    entryTime.toString(),
                    '},{"display_type":"number","max_value":"9","trait_type":"Balance Level","value":',
                    balanceLevel.toString(),
                    '},{"display_type":"number","max_value":"9","trait_type":"Duration Level","value":',
                    durationLevel.toString(),
                    '}],"image":"data:image/svg+xml;base64,',
                    svg,
                    '"}\n'
                )
            );
        }

        return string(abi.encodePacked("data:application/json;base64,", json));
    }

    function addThousandSeperator(uint256 value) private view returns (string memory) {
        bytes memory digits = bytes(value.toString());
        uint256 digitsLength = digits.length;
        uint256 seperatorsLength = digitsLength <= 3 ? 0 : (digitsLength - 1) / 3;
        uint256 shift = digitsLength % 3;
        uint256 seperatorCount = 0;
        bytes memory buffer = new bytes(digitsLength + seperatorsLength);
        for (uint256 i = 0; i < digitsLength; ++i) {
            if (i != 0 && i >= shift && i % 3 == shift) {
                ++seperatorCount;
                buffer[i + seperatorCount - 1] = thousandSeperator;
            }
            buffer[i + seperatorCount] = digits[i];
        }
        return string(buffer);
    }

    function getImageUri(uint256 balanceLevel, uint256 durationLevel)
        private
        view
        returns (string memory)
    {
        return string(
            abi.encodePacked(
                imageBaseUri,
                balanceLevel.toString(),
                durationLevel.toString(),
                imageExtension
            )
        );
    }

    function getExponent(uint256 value) private pure returns (uint256) {
        if (value >= 8103) return 9;
        if (value >= 2981) return 8;
        if (value >= 1097) return 7;
        if (value >= 403) return 6;
        if (value >= 148) return 5;
        if (value >= 55) return 4;
        if (value >= 20) return 3;
        if (value >= 7) return 2;
        if (value >= 3) return 1;
        return 0;
    }

    function parseEther(uint256 a) private pure returns (uint256) {
        return a % 1 ether >= 1 ether / 2 ? a / 1 ether + 1 : a / 1 ether;
    }
}
